<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SOLID Examples</title>
    <link rel="stylesheet" href="/css/solid.css">
</head>
<body>
<div class="app-shell">
    <header class="app-header">
        <div class="title-block">
            <h1>SOLID Principle Examples</h1>
            <span>Side‑by‑side good vs bad implementations in a Spring Boot app</span>
        </div>
        <div class="badge">Interactive Playground</div>
    </header>

    <section class="description-card">
        <div class="description-main">
            <p>Use the controls below to execute each SOLID example.</p>
            <p>Each button calls a REST endpoint and shows a short explanation here that describes the principle, the bad design, and how the good design improves it.</p>
        </div>
        <div class="legend">
            <div class="legend-item">
                <div class="dot bad"></div>
                <span>Bad design (anti‑example)</span>
            </div>
            <div class="legend-item">
                <div class="dot good"></div>
                <span>Good design (SOLID‑aligned)</span>
            </div>
        </div>
    </section>

    <main class="solid-row">
        <section class="solid-item">
            <div class="solid-letter">S</div>
            <div class="button-row">
                <button class="bad" onclick="runExample('srp/bad')">
                    SRP Bad
                </button>
                <button class="good" onclick="runExample('srp/good')">
                    SRP Good
                </button>
            </div>
        </section>

        <section class="solid-item">
            <div class="solid-letter">O</div>
            <div class="button-row">
                <button class="bad" onclick="runExample('ocp/bad')">
                    OCP Bad
                </button>
                <button class="good" onclick="runExample('ocp/good')">
                    OCP Good
                </button>
            </div>
        </section>

        <section class="solid-item">
            <div class="solid-letter">L</div>
            <div class="button-row">
                <button class="bad" onclick="runExample('lsp/bad')">
                    LSP Bad
                </button>
                <button class="good" onclick="runExample('lsp/good')">
                    LSP Good
                </button>
            </div>
        </section>

        <section class="solid-item">
            <div class="solid-letter">I</div>
            <div class="button-row">
                <button class="bad" onclick="runExample('isp/bad')">
                    ISP Bad
                </button>
                <button class="good" onclick="runExample('isp/good')">
                    ISP Good
                </button>
            </div>
        </section>

        <section class="solid-item">
            <div class="solid-letter">D</div>
            <div class="button-row">
                <button class="bad" onclick="runExample('dip/bad')">
                    DIP Bad
                </button>
                <button class="good" onclick="runExample('dip/good')">
                    DIP Good
                </button>
            </div>
        </section>
    </main>

    <section>
        <div id="output-label">
            <div id="output-label-pill"></div>
            <span>Last example output</span>
        </div>
        <div id="output">Result will appear here.</div>
    </section>

    <section class="solid-details">
        <div>
            <h2>About SOLID</h2>
            <p>SOLID is a set of five design principles that make object‑oriented systems easier to understand, change, and test.</p>
            <p>The buttons above execute bad and good implementations so you can see how these ideas affect real code.</p>
        </div>
        <div class="solid-list">
            <div class="solid-item-detail">
                <h3>S – Single Responsibility Principle</h3>
                <span>One reason to change</span>
                <p>Each class should have one clear responsibility. The bad SRP example has a single service that saves users, sends emails, and writes audit logs, so many reasons to change pile up in one place. The good example keeps UserService focused on the use case and delegates persistence, notifications, and auditing to separate collaborators, making changes and testing much easier.</p>
            </div>
            <div class="solid-item-detail">
                <h3>O – Open/Closed Principle</h3>
                <span>Open for extension, closed for modification</span>
                <p>Behavior should be extended through new code, not by editing stable classes. The bad OCP example grows a conditional in DiscountCalculator for every CustomerType, so adding one more type means touching existing logic. The good example depends on a DiscountPolicy abstraction, so new customer types are added as new policy classes without modifying the price calculator.</p>
            </div>
            <div class="solid-item-detail">
                <h3>L – Liskov Substitution Principle</h3>
                <span>Subtypes should be substitutable</span>
                <p>Subclasses must honor the expectations of their base types. In the bad LSP example, ReadOnlyDocument extends Document but fails when code calls setContent, so using it as a Document can cause runtime errors. The good example models read-only and writable concerns with ReadableDocument and WritableDocument, so each implementation truly supports the operations its type promises.</p>
            </div>
            <div class="solid-item-detail">
                <h3>I – Interface Segregation Principle</h3>
                <span>Small, focused interfaces</span>
                <p>Clients should not depend on methods they do not use. The bad ISP example defines a Worker interface with work, eat, and sleep, forcing RobotWorker to implement methods that do not make sense and may even throw at runtime. The good example splits capabilities into Workable, Eatable, and Sleepable so each client and implementation only depends on relevant operations.</p>
            </div>
            <div class="solid-item-detail">
                <h3>D – Dependency Inversion Principle</h3>
                <span>Depend on abstractions</span>
                <p>High‑level modules should not depend on concrete details. The bad DIP example has PasswordResetService create a concrete SmtpEmailSender with new, tightly coupling the logic to one email mechanism. The good example makes PasswordResetService depend on the EmailSender abstraction instead, so different implementations can be injected or mocked without changing the high‑level code.</p>
            </div>
        </div>
    </section>
</div>

<script>
    function runExample(path) {
        const output = document.getElementById('output');
        output.textContent = 'Running ' + path + '...';
        fetch('/api/' + path)
            .then(function (response) {
                if (!response.ok) {
                    throw new Error('HTTP ' + response.status);
                }
                return response.text();
            })
            .then(function (text) {
                output.textContent = text;
            })
            .catch(function (error) {
                output.textContent = 'Error: ' + error.message;
            });
    }
</script>
</body>
</html>
